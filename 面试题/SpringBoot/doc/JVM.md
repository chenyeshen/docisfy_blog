# JVM

#### 1. 请简单描述JDK和JRE的区别？以下的回答大家觉得还好吧

答：JDK就是支持java开发者完成变成所需要的语言支持环境，而JRE则不需要JDK那么强大的工具，只需要能运行JAVA程序就可以了

#### 2. 什么是类加载器，类加载器有哪些?

实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。
主要有一下四种类加载器:
\1. 启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。
\2. 扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
\3. 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。
\4. 用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。

#### 3. 简述java类加载机制?

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。

#### 4. java类加载过程?

java类加载需要经历一下7个过程：
加载
加载时类加载的第一个过程，在这个阶段，将完成一下三件事情：
\1. 通过一个类的全限定名获取该类的二进制流。
\2. 将该二进制流中的静态存储结构转化为方法去运行时数据结构。 
\3. 在内存中生成该类的Class对象，作为该类的数据访问入口。

验证
验证的目的是为了确保Class文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证:
\1. 文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.
\2. 元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。
\3. 字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。
\4. 符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。

准备
准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。

​    public static int value=123;*//在准备阶段value初始值为0 。在初始化阶段才会变为123 。*

解析
该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。

初始化
初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。

#### 5. class加载的过程

首先，在代码编译后，就会生成JVM（Java虚拟机）能够识别的二进制字节流文件（*.class）。而JVM把Class文件中的类描述数据从文件加载到内存，并对数据进行校验、转换解析、初始化，使这些数据最终成为可以被JVM直接使用的Java类型，这个说来简单但实际复杂的过程叫做JVM的类加载机制。

![img](file:///C:\Users\yeshen\AppData\Local\Temp\ksohtml3824\wps3.jpg)我们平常说的加载大多不是指的类加载机制，只是类加载机制中的第一步加载。

 

JVM主要完成三件事：

 

通过一个类的全限定名（包名与类名）来获取定义此类的二进制字节流（Class文件）。而获取的方式，可以通过jar包、war包、网络中获取、JSP文件生成等方式。

 

将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。这里只是转化了数据结构，并未合并数据。（方法区就是用来存放已被加载的类信息，常量，静态变量，编译后的代码的运行时内存区域）

 

在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。这个Class对象并没有规定是在Java堆内存中，它比较特殊，虽为对象，但存放在方法区中。

 

启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。

 

扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。

 

应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

 

应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：

 

1）在执行非置信代码之前，自动验证数字签名。

 

2）动态地创建符合用户特定需要的定制化构建类。

 

3）从特定的场所取得java class，例如数据库中和网络中。

 

JVM类加载机制

•全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入

 

•父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类

 

•缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效

 

类加载有三种方式：

1、命令行启动应用时候由JVM初始化加载

 

2、通过Class.forName()方法动态加载

 

3、通过ClassLoader.loadClass()方法动态加载

#### 6. 类加载器双亲委派模型机制？

当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。

#### 7. JVM的类加载过程？

![img](file:///C:\Users\yeshen\AppData\Local\Temp\ksohtml3824\wps4.jpg) 

什么是类加载机制？ 
在一个java程序运行时，虚拟机并不会立刻将这个程序所有的类信息加载到内存中，而是在这个类第一次被使用时进行加载。将一个类加载到虚拟机内存中的过程称为类加载机制。 
注意：一个类在一条JVM进程中只会被加载一次。

#### 8. 你知道哪些或者你们线上使⽤什么GC策略？它有什么优势，适⽤于什么场景？

参考 触发JVM进行Full GC的情况及应对策略。

#### 9. 简述堆和栈的区别

VM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享

#### 10. 简述JVM内存分配

(1)基本数据类型比变量和对象的引用都是在栈分配的

(2)堆内存用来存放由new创建的对象和数组

(3)类变量（static修饰的变量），程序在一加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中

(4)实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”,实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存

(5)局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放

#### 11. java内存模型

java内存模型(JMM)是线程间通信的控制机制.JMM定义了主内存和线程之间抽象关系。线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下： 
从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：
\1. 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。
\2. 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。
写的很好:<http://www.infoq.com/cn/articles/java-memory-model-1>

#### 12. JVM内存分哪几个区，每个区的作用是什么?

java虚拟机主要分为以下一个区:

方法区：
\1. 有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载
\2. 方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。
\3. 该区域是被线程共享的。
\4. 方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。

虚拟机栈:
\1. 虚拟机栈也就是我们平常所称的栈内存,它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。
\2. 虚拟机栈是线程私有的，它的生命周期与线程相同。
\3. 局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定
4.操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式
5.每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。

本地方法栈
本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务。

堆
java堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。

程序计数器
内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。

#### 13. JVM中survivor区存在的意义是啥

在任何时候，总有一个survivor space是empty的，在下一次coping collection时，会将eden和另一个survivor space里的live object copy到这个里面。

live objects在两个survivor space里copy来copy去，直到对象old enough可以放到tenured generation里（copy 过去的）

因为在垃圾收集的时候需要将dead object清理掉，如果只有一个survivor区，那么这个survivor区里的dead object在清理掉之后就会产生内存碎片，为了避免内存碎片那么必须将live object移动来移动去，这样就会损失性能。

如果有两个survivor区，按照上面的说法，就不会存在内存碎片的问题。

#### 14. Java类加载器包括⼏种？它们之间的⽗⼦关系是怎么样的？

启动Bootstrap类加载、扩展Extension类加载、系统System类加载。

父子关系如下：

启动类加载器 ，由C++ 实现，没有父类；

扩展类加载器，由Java语言实现，父类加载器为null；

系统类加载器，由Java语言实现，父类加载器为扩展类加载器；

自定义类加载器，父类加载器肯定为AppClassLoader。

#### 15. 谈谈JVM中，对类加载器的认识

答：类加载器是JVM的组成部分之一。将字节码文件加载进JVM。

类加载分为四部分：

BootStrapClassLoader，即跟类加载器，加载java运行时所需的类，如String，Integer等存在${java_home}/jre/lib/rt.jar包类的所有类。

ExtensionClassLoader,扩展类加载器，加载一些扩展类，即${java_home}/jre/lib/ext/*.jar包

AppClassLoader，系统加载类，加载自定义的类，级classpath下的所有类

ClassLoader 抽象类加载器：用户自定义的类加载器，用户定义的类加载器都要继承次ClassLoader

Jvm默认采用的是双亲委派类加载机制，即先加载父类在加载子类，对上面四个类加载器采用自顶向下加载

#### 16. 双亲委派机制是什么意思？有什么好处？

双亲委派机制：类加载器收到类加载请求，自己不加载，向上委托给父类加载，父类加载不了，再自己加载。

优势避免Java核心API篡改。详细查看：深入理解Java类加载器(ClassLoader)

#### 17. 如何⾃定义⼀个类加载器？你使⽤过哪些或者你在什么场景下需要⼀个⾃定义的类加载器吗？

自定义类加载的意义：

加载特定路径的class文件

加载一个加密的网络class文件

热部署加载class文件

#### 18. 堆内存设置的参数是什么？

-Xmx 设置堆的最大空间大小

-Xms 设置堆的最小空间大小

#### 19. 新生代与老年代的划分

对象有限分配在Eden，Eden没空间则进行一次Minor GC（新生代GC）

长期存活的对象，进入老年代，默认为15次，初始为0，每经过一次Minor GC+1，默认15晋升老年代，也可以调整阀值

大于阀值 PretenureSizeTreshold的直接进入老年代，避免Eden与两个Survivor产生大量的内存复制。

动态对象年龄判定：如果在Survivor中相同连年大小的总和大于Survivor的一般，年龄大于或者等于该年龄的对象直接进入老年代

 

空间分配担当：如果老年代最大可用的连续空间大于新生代所有的对象的总空间，Minor Gc则可以确保是安全的的，可以设置是否允许担保失败，如果允许，则尝试进行MinorGC，否则进行FullGC。如果MinorGC存活对象过多，出现了HandlePromotionFailure，则在失败后发起FullGC。

 

一般允许担保失败，避免FullGC过于频繁。

 

#### 20. Perm Space中保存什么数据？会引起OutOfMemory吗？

加载class文件。会引起，出现异常可以设置 -XX:PermSize 的大小。JDK 1.8后，字符串常量不存放在永久带，而是在堆内存中，JDK8以后没有永久代概念，而是用元空间替代，元空间不存在虚拟机中，二是使用本地内存。

详细查看Java8内存模型—永久代(PermGen)和元空间(Metaspace)

#### 21. 做GC时，⼀个对象在内存各个Space中被移动的顺序是什么？

标记清除法，复制算法，标记整理、分代算法。

新生代一般采用复制算法 GC，老年代使用标记整理算法。

垃圾收集器：串行新生代收集器、串行老生代收集器、并行新生代收集器、并行老年代收集器。

CMS（Current Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-Sweep算法。

详见 Java GC机制。

#### 22. 你有没有遇到过OutOfMemory问题？你是怎么来处理这个问题的？处理 过程中有哪些收获？

permgen space、heap space 错误。

常见的原因

内存加载的数据量太大：一次性从数据库取太多数据；

集合类中有对对象的引用，使用后未清空，GC不能进行回收；

代码中存在循环产生过多的重复对象；

启动参数堆内存值小。

详见 Java 内存溢出（java.lang.OutOfMemoryError）的常见情况和处理方式总结。

#### 23. JDK 1.8之后Perm Space有哪些变动? MetaSpace⼤⼩默认是⽆限的么? 还是你们会通过什么⽅式来指定⼤⼩?

JDK 1.8后用元空间替代了 Perm Space；字符串常量存放到堆内存中。

MetaSpace大小默认没有限制，一般根据系统内存的大小。JVM会动态改变此值。

-XX:MetaspaceSize：分配给类元数据空间（以字节计）的初始大小（Oracle逻辑存储上的初始高水位，the initial high-water-mark）。此值为估计值，MetaspaceSize的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。

-XX:MaxMetaspaceSize：分配给类元数据空间的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。

#### 24. jstack是⼲什么的? jstat 呢？如果线上程序周期性地出现卡顿，你怀疑可能是 GC 导致的，你会怎么来排查这个问题？线程⽇志⼀般你会看其中的什么部分？

jstack 用来查询 Java 进程的堆栈信息。

jvisualvm 监控内存泄露，跟踪垃圾回收、执行时内存、cpu分析、线程分析。

详见Java jvisualvm简要说明，可参考 线上FullGC频繁的排查。 

#### 25. StackOverflow异常有没有遇到过？⼀般你猜测会在什么情况下被触发？如何指定⼀个线程的堆栈⼤⼩？⼀般你们写多少？

栈内存溢出，一般由栈内存的局部变量过爆了，导致内存溢出。出现在递归方法，参数个数过多，递归过深，递归没有出口。

#### 26. minor gc、major gc、full gc使用了哪种垃圾回收算法，为什么

先来讲一下这几个算法的特性吧

复制：1.将内存分为两块，只用一块，另一块用来讲这一块的对象复制；2.不会产生内存碎片

标记-清除：1.从引用根节点开始标记所有被引用的对象；2.遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。

标记-整理：1.从根节点开始标记所有被引用对象；2.遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。

![img](file:///C:\Users\yeshen\AppData\Local\Temp\ksohtml3824\wps5.jpg) 

新生代的Minor GC触发条件：Copying算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中，对应于新生代，就是在Eden和FromSpace或ToSpace之间copy。所有的Minor GC都会触发全世界的暂停（stop-the-world）

老年代的GC（Major GC/Full GC）：老年代与新生代不同，老年代对象存活的时间比较长、比较稳定，因此采用标记(Mark)算法来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并、要么标记出来便于下次进行分配，总之目的就是要减少内存碎片带来的效率损耗。

#### 27. 如和判断一个对象是否存活?或者GC对象的判定方法

判断一个对象是否存活有两种方法:

1. 引用计数法
   所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收.
   引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象A引用对象B，对象B又引用者对象A，那么此时A,B对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。

2.可达性算法(引用链法)
该算法的思想是：从一个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。
在java中可以作为GC Roots的对象有以下几种:

l 虚拟机栈中引用的对象

l 方法区类静态属性引用的对象

l 方法区常量池引用的对象

l 本地方法栈JNI引用的对象

虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达GC Root时，这个对象并 
不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记
如果对象在可达性分析中没有与GC Root的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者已被虚拟机调用过，那么就认为是没必要的。
如果该对象有必要执行finalize()方法，那么这个对象将会放在一个称为F-Queue的对队列中，虚拟机会触发一个Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果finalize()执行缓慢或者发生了死锁，那么就会造成F-Queue队列一直等待，造成了内存回收系统的崩溃。GC对处于F-Queue中的对象进行第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收。

#### 28. java中垃圾收集的方法有哪些?

标记-清除:
这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：1.效率不高，标记和清除的效率都很低；2.会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次GC动作。

复制算法:
为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。
于是将该算法进行了改进，内存区域不再是按照1：1去划分，而是将内存划分为8:1:1三部分，较大那份内存交Eden区，其余是两块较小的内存区叫Survior区。每次都会优先使用Eden区，若Eden区满，就将对象复制到第二块内存区上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制复制到老年代中。(java堆又分为新生代和老年代)

标记-整理
该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。

分代收集 
现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。

#### 29. 垃圾回收算法

标记清除算法 Mark-sweep 

存在效率问题与空间问题（产生大量不连续的内存碎片）

复制算法（Copying）：应用十分广泛，将内存分为一块较大的Eden和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。回收时，将Eden与Survivor复制到另一块Survivor是哪个。 

默认Eden与Survivor的比例是8:1

标记整理算法（Mark-Compact） 适用于老年代，将所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

#### 30. 垃圾回收的其他概念

Stop The World：从GC Roots进行可达性分析是，为了保持一致性，停顿所有的Java执行线程。就像时间冻结

准确式GC：虚拟机可以知道内存中某个位置的数据具体是什么类型

OopMaps：用来记录对象引用，HotSpot使用,类加载过程中，把对象内的偏移量上是什么数据计算出来。

安全点：SafePoint 既程序执行时并非在所有地方都能停顿下来，只有安全点才能停顿。程序长时间执行的特征，例如：方法调用、循环跳转、异常跳转等

抢先式中断和主动式中断：抢先式首先把所有的线程全部中断，如果发现有线程不在安全点上，则回复线程；主动式中断：通过设置标志，线程执行时轮询标志，发现标志则自己中断。

安全区域（Safe Region）：如果程序不执行的时候，就没法中断，所以需要安全区域，一段代码片段中，应用关系不发生变化，则为安全区域

#### 31. 垃圾回收器

Serial：新生代，采用复制算法，老年代采用标记整理算法，单线程，需要Stop The Worls，Client模式下的默认新生代收集器

ParNew：Serial的多线程版本，新生代采用复制算法，老年代采用标记整理算法。Server模式的首选新生代收集器，因为目前只有它与Serial能与CMS收集器配合工作，在多CPU>2的情况下，有更好的性能

Parallel（并行） Scavenge：新生代收集器，复制算法，关注吞吐量，吞吐量=运行用户代码的时间/（运行用户代码的时间+垃圾收集时间），适合在后台运算而不需要太多交互的任务。可以设置吞吐量大小eg：GCTimeRatio，也成为吞吐量优先收集器。可以自动控制新生代的大小、Eden与Suvivor的比例、晋升老年代的年龄，自适应调节策略是Paralle Scavenge与Parnew的最大区别

Serial Old：serial老年代版本，client模式下使用，可以为Paralle Scavenge收集器搭配使用，或者作为CMS的后备

Parallel Old：Parallel Scavenge的老年代版本，标记整理算法，注重吞吐量与CPU资源敏感，可以用优先使用Parallel Scavengen+Parallel Old

CMS（Concurrent并发 Mark Sweep）：一种获取最短回收停顿时间为目标的收集器。目前大量使用在互联网站或者B/S系统的服务端上，尤其重视服务的响应速度。基于标记-清除算法

#### 32. FullGC 、Minor Gc 、Major GC

Full==MajorGC

 

Minor GC:新生代垃圾回收，非常频繁，一般速度比较快 

Major Gc：老年代垃圾回收，经常会伴随一次MinorGC，一般比MinorGC慢10倍以上

 

#### 33. 判断对象是否存活一般有两种方式

引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。

可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。

#### 34. 哪些对象可作为GC Roots对象？

虚拟机栈中应用的对象

方法区里面的静态对象

方法区常量池的对象

本地方法栈JNI应用的对象

#### 35. 10. 双亲委托模型

从JDK1.2开始，java虚拟机规范推荐开发者使用双亲委派模式(ParentsDelegation Model)进行类加载，其加载过程如下：

 

(1).如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器去完成。

 

(2).每一层的类加载器都把类加载请求委派给父类加载器，直到所有的类加载请求都应该传递给顶层的启动类加载器。

 

(3).如果顶层的启动类加载器无法完成加载请求，子类加载器尝试去加载，如果连最初发起类加载请求的类加载器也无法完成加载请求时，将会抛出ClassNotFoundException，而不再调用其子类加载器去进行类加载。

 

双亲委派模型意义：

 

系统类防止内存中出现多份同样的字节码

 

保证Java程序安全稳定运行

 

双亲委派 模式的类加载机制的优点是java类它的类加载器一起具备了一种带优先级的层次关系，越是基础的类，越是被上层的类加载器进行加载，保证了java程序的稳定运行。双亲委派模式的实现：

![img](file:///C:\Users\yeshen\AppData\Local\Temp\ksohtml3824\wps6.jpg)http://blog.csdn.net/p10010/article/details/50448491

 

#### 36. 11. 如何 加载自定义的Jar包

两种办法 

\1. 使用URLClassloader来进行加载，需要指定路径，可以加载子类和方法的实现类 

\2. 使用manifest.mf文件来加载，将jar包填入classpath里面

 

#### 37. 12. Java JMX

JAVA_OPTS=-Dcom.sun.management.jmxremote

 

#### 38. 13. Java远程调试

Java远程调试的原理是两个VM之间通过debug协议进行通信，然后以达到远程调试的目的。两者之间可以通过socket进行通信。

首先被debug程序的虚拟机在启动时要开启debug模式，启动debug监听程序。jdwp是Java Debug Wire Protocol的缩写。

java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n zhc_application

这是jdk1.7版本之前的方法，1.7之后可以这样用：

java -agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n zhc_application

然后用一个debug客户端去debug远程的程序了，比如用Eclipse自带的debug客户端，填写运行被debug程序的虚拟机监听的端口号和地址，选择connect方式为attach。

#### 39. 2.GC的回收流程是怎样的？

GC回收流程如下：

 

对于整个的GC流程里面，那么最需要处理的就是新生代和老年代的内存清理操作，而元空间（永久代）都不在GC范围内

当现在有一个新的对象产生，那么对象一定需要内存空间，平均每个栈内存存4k，每个堆内存存8k，那么对象一定需要进行堆空间的申请

首先会判断Eden区是否有内存空间，如果此时有内存空间，则直接将新对象保存在伊甸园区。

但是如果此时在伊甸园区内存不足，那么会自动执行一个Minor GC 操作，将伊甸园区的无用内存空间进行清理，Minor GC的清理范围只在Eden园区，清理之后会继续判断Eden园区的内存空间是否充足？如果内存空间充足，则将新对象直接在Eden园区进行空间分配。

如果执行Minor GC 之后发现伊甸园区的内存空间依然不足，那么这个时候会执行存活区的判断，如果存活区有剩余空间，则将Eden园区部分活跃对象保存在存活区，那么随后继续判断Eden园区的内存空间是否充足，如果充足怎则将新对象直接在Eden园区进行空间分配。

此时如果存活区没有内存空间，则继续判断老年区。则将部分存活对象保存在老年代，而后存活区将有空余空间。

如果这个时候老年代也满了，那么这个时候将产生Major GC（Full GC）,那么这个时候将进行老年代的清理

如果老年代执行Full GC之后，无法进行对象的保存，则会产生OOM异常,OutOfMemoryError异常

#### 40. 3.请解释StackOverflowError和OutOfMemeryError的区别？

通过之前的分析可以发现，实际上每一块内存中都会存在有一部分的可变伸缩区，其基本流程为：如果空间内存不足，在可变范围之内扩大内存空间，当一段时间之后发现内存充足，会缩小内存空间。

永久代（JDK 1.8后消失了）

虽然java的版本是JDK1.8，但是java EE 的版本还是jdk1.7，永久代存在于堆内存之中

元空间

元空间在Jdk1.8之后才有的，器功能实际上和永久代没区别，唯一的区别在于永久代使用的是JVM的堆内存空间，元空间使用的是物理内存，所以元空间的大小受本地内存影响，一般默认在2M 左右。

范例：设置一些参数，让元空间出错

Java -XX:MetaspaceSize=1m

#### 41. 4.JVM的引用类型有哪些？

引用内型：

强引用：当内存不足的时候，JVM宁可出现OutOfMemoryError错误停止，也需要进行保存，并且不会将此空间回收。在引用期间和栈有联系就无法被回收

软引用：当内存不足的时候，进行对象的回收处理，往往用于高速缓存中；mybatis就是其中

弱引用：不管内存是否紧张，只要有垃圾了就立即回收

幽灵引用：和没有引用是一样的

#### 42. 5.说说垃圾回收期的一些常见算法？

GC算法：

引用计数法：对于一个 对象A，只要引用一次就加1，引用失效减一，当计数为0时就失效

根搜索算法：判断是否可达：需要和根节点有依赖关系。如果没有和我的GCroots有关

标记-清除

标记-清除分为两个阶段：标记和清除，从根节点对对象就行标记，从根节点开始可达的对象就标记，清除阶段 清除未被标记的对象

标记-压缩

标记出对象是否存活，移动存活对象，移动完之后，清理边界外的对象

标记压缩对标记清除而言，有什么优势呢？

复制算法

#### 43. 6.请你谈谈你对JVM的理解？Java8的虚拟机有什么更新

答：在这里我就不说JVM是java虚拟机了。先谈谈java文件的运行过程一个*.java文件通过编译器编译成字节码文件，然后由JVM的类加载字节码文件，由执行引擎执行。在这期间类加载器加载的数据会与java运行时数据区进行交互。在这里看来JVM内存划分为类加载器，执行引擎，本地方法接口，java运行时数据区。其中java运行时数据区划分为：程序计数器，虚拟机栈，本地方法栈，堆，方法区

程序计数器：指向当前正在执行线程的字节码地址的指令或行号。属于线程私有的。

虚拟机栈：存储当前线程运行方法所需的数据指令，访问地址（java独有的）

Java虚拟机栈划分为四个部分：局部变量表，操作数栈，动态链接，方法出口

本地方法栈：存储本地方法

方法区：方法区包含静态变量+类信息+字面量常量+运行时常量池

堆：对象的新建都在堆区完成，JAVA中的GC主要操作的是这个区域

堆区在逻辑上划分为:新生代，老年代，永久代（java7），在java8将堆区在逻辑上划分为:新生代，老年代和元空间（Meta Space），元空间默认大小为2M左右，其中新生代又分为Eden区，存活区，存活区由；两块大小相等的内存空间组成（即s0区,s1区），也叫from区和to区，JVM在的堆区在物理上只有两块区：新生代和老年代。Java8的虚拟机的更新:元空间将永久代取代，为什么会更新呢?Oracle整合了Sun公司的Hotspot和BEA公司的Jrocket，从而将永久代去掉用元空间取代，永久代和元空间有什么区别？元空间在Jdk1.8之后才有的，其功能实际上和永久代没区别，唯一的区别在于永久代使用的是JVM的堆内存空间，元空间使用的是物理内存，所以元空间的大小受本地内存影响。

在来谈谈方法区和永久代的关系：方法区相当去定义了UserService，永久代相当去UserServiceImpl。即接口和实现类的关系

#### 44. 请解释StackOverflowError和OutOfMemeryError的区别？

答:StackOverflowError栈溢出，一般由于递归过多，调用方法过多导致

OutOfMemeryError堆内存溢出，即OOM，由于堆内存中没有被GC回收的对象过多导致。

出现OOM的原因:

（-）.Java虚拟机的堆内存设置不够，可以通过参数-Xms和-Xmx来调优

（二）程序中创建了大量对象，并且长时间不能被被垃圾回收器回收（存在引用）

#### 45. 7.JVM的常用参数调优你知道哪些?

两个:一个-Xms堆内存初始化大小，一般默认为物理内存的六十四分之一

一个-Xmx堆内存最大分配空间，一般默认为物理内存的四分之一

#### 46. 8.内存快照抓取和MAT分析DUMP文件知道吗？

#### 47. 10.在JVM中，如何判断一个对象是否死亡？

判断对象是否死亡有两种方法：1.引用计数法，2.可达性分析算法

引用计数法是最简单最古老的算法，JVM为每个对象分配一个计数器，当对象被引用时，计数器就加1，当对象没有被引用或者离开作用域，计数器就减1。当计数器的值为0时，就代表该对象已经死亡

可达性分析算法，是用ＧＣROOTs 作为对象的起点开始往下搜索，能搜索到这个对象，就表示对象是可达的，不能搜素到表示对象是不可达的

可作为GCRoots的对象包括下面几种：

虚拟机栈中引用的对象

方法区中类静态属性引用的对象

方法区中常量引用的对象

本地方法栈中引用的对象

#### 48. 11.举例几种常见的垃圾收集算法？

1.标记清除法：标记清除法用在新生代，首先标记出所需要回收的对象，在标记完成后统一回收所有被标记的对象

2.复制算法：复制算法用在存活区，把不需要回收的对象全部放在s0/s1区，然后将s1/s0区进行统一的清理

 	3.标记整理法： 标记整理法用在老年代，将需要回收的对象压缩在一边进行垃圾回收

#### 49. 简述java垃圾回收机制?

在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。

#### 50. 什么情况下会发生栈内存溢出。

a.方法创建了一个很大的对象，如List，Array
b.是否产生了循环调用、死循环
c.是否引用了较大的全局变量

#### 51. JVM的内存结构，Eden和Survivor比例。

JVM内存结构分为两种类型：
线程安全：虚拟机栈、本地方法栈、程序计数器
非线程安全：堆，方法区
虚拟机栈：每个方法被执行时，都会在内存中创建一个空间用来存储方法中的局部变量，方法的出入口等信息。
本地方法栈：每个本地方法被执行时，都会创建一个内存空间，用来存储本地方法中的局部变量，方法的出入口等信息。
程序计数器：是当前程序所执行的class文件的行号指示器，通过改变行号来决定下一段要执行的字节码指令，跳转，循环，异常处理
堆：每一个对象的创建跟分配都是在堆上面进行的，堆分为新生代，老生代。新生代有一个Eden和两个Survivor组成，默认比例是8：2。也可以使用-XXSurvivorRatio来改变百分比。
方法区：用来存放类的版本，类的方法还有static修饰的对象等信息。

#### 52. jvm中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的jvm参数。

![img](file:///C:\Users\yeshen\AppData\Local\Temp\ksohtml3824\wps7.jpg) 

对象晋升老生代一共有三个可能：

1.当对象达到成年，经历过15次GC（默认15次，可配置），对象就晋升为老生代

2.大的对象会直接在老生代创建

3.新生代跟幸存区内存不足时，对象可能晋升到老生代

jvm参数：

-Xms：初始堆大小

-Xmx：堆最大内存

-Xss：栈内存

-XX:PermSize 初始永久带内存

-XX:MaxPermSize 最大永久带内存

#### 53. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms，包括原理，流程，优缺点

串行垃圾收集器：收集时间长，停顿时间久
并发垃圾收集器：碎片空间多
CMS:并发标记清除。他的主要步骤有：初始收集，并发标记，重新标记，并发清除（删除），重置
G1：主要步骤：初始标记，并发标记，重新标记，复制清除（整理）
CMS的缺点是对cpu的要求比较高。G1是将内存化成了多块，所有对内段的大小有很大的要求
CMS是清除，所以会存在很多的内存碎片。G1是整理，所以碎片空间较小

#### 54. 垃圾回收算法的实现原理。

常用的垃圾回收算法有两种： 引用计数和可达性分析

引用计数是增加一个字段来标识当前的引用次数，引用计数为0的就是可以GC的。但是引用计数不能解决循环引用的问题
可达性分析：就是通过一系列GC ROOT的对象作为起点，向下搜索，搜索所有没有与当前对象GC ROOT 有引用关系的对象。这些对象就是可以GC的。

#### 55. 当出现了内存溢出，你怎么排错。

1.首先控制台查看错误日志

2.然后使用jdk自带的jvisualvm工具查看系统的堆栈日志

3.定位出内存溢出的空间：堆，栈还是永久代（jdk8以后不会出现永久代的内存溢出）。

4.如果是堆内存溢出，看是否创建了超大的对象

5.如果是栈内存溢出，看是否创建了超大的对象，或者产生了死循环。

#### 56. JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。

重排序：jvm虚拟机允许在不影响代码最终结果的情况下，可以乱序执行。

内存屏障：可以阻挡编译器的优化，也可以阻挡处理器的优化

happens-before原则：

1：一个线程的A操作总是在B之前，那多线程的A操作肯定实在B之前。
2：monitor 再加锁的情况下，持有锁的肯定先执行。
3：volatile修饰的情况下，写先于读发生
4：线程启动在一起之前 strat
5：线程死亡在一切之后 end
6：线程操作在一切线程中断之前
7：一个对象构造函数的结束都该对象的finalizer的开始之前
8：传递性，如果A肯定在B之前，B肯定在C之前，那A肯定是在C之前。

主内存：所有线程共享的内存空间

工作内存：每个线程特有的内存空间

#### 57. 简单说说你了解的类加载器。

类加载器主要分为：引导类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader），系统类加载器（App ClassLoader）和自定义加载器（Custom ClassLoader）

双亲委派：双亲委派模式会保证父类加载器先加载类

#### 58. g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。

CMS:并发标记清除。他的主要步骤有：初始收集，并发标记，重新标记，并发清除（删除），重置
G1：主要步骤：初始标记，并发标记，重新标记，复制清除（整理）

CMS的缺点是对cpu的要求比较高。G1是将内存化成了多块，所有对内段的大小有很大的要求

CMS是清除，所以会存在很多的内存碎片。G1是整理，所以碎片空间较小

吞吐量优先：G1

响应优先：CMS

#### 59. 请解释如下jvm参数的含义：

 -server -Xms512m -Xmx512m -Xss1024K -XX:PermSize=256m -XX:MaxPermSize=512m -XX:MaxTenuringThreshold=20 XX:CMSInitiatingOccupancyFraction=80 -XX:+UseCMSInitiatingOccupancyOnly。

-server：服务器模式

-Xms512m ：初始堆空间

-Xmx512m：最大堆空间

-Xss1024K ：栈空间

-XX:PermSize=256m ：初始永久带空间

-XX:MaxPermSize=512m ：最大永久带空间

-XX:MaxTenuringThreshold=20 ：对象的生命周期

XX:CMSInitiatingOccupancyFraction=80 ：老年代的内存在使用到70%的时候，就开始启动CMS了

-XX:+UseCMSInitiatingOccupancyOnly：它就只会按照你设置的比率来启动CMS GC了

 

一）GC的主要任务：
1.分配内存；
2.确保被引用对象的内存不被错误的回收；
3.回收不再被引用的对象的内存空间

#### 60. 简述java内存分配与回收策率以及Minor GC和Major GC

对象优先在堆的Eden区分配。

(1)大对象直接进入老年代.

(2)长期存活的对象将直接进入老年代.
(3)当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC.Minor Gc通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生Gc的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC,但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度。

#### 61. 类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序

答：先静态、先父后子。 

先静态：父静态 > 子静态 

优先级：父类 > 子类 静态代码块 > 非静态代码块 > 构造函数 

一个类的实例化过程： 

1，父类中的static代码块，当前类的static 

2，顺序执行父类的普通代码块 

3，父类的构造函数 

4，子类普通代码块 

5，子类（当前类）的构造函数，按顺序执行。 

6，子类方法的执行，

#### 62. JVM垃圾回收机制，何时触发MinorGC等操作

分代垃圾回收机制：不同的对象生命周期不同。把不同生命周期的对象放在不同代上，不同代上采用最合适它的垃圾回收方式进行回收。 

JVM中共划分为三个代：年轻代、年老代和持久代， 

年轻代：存放所有新生成的对象； 

年老代：在年轻代中经历了N次垃圾回收仍然存活的对象，将被放到年老代中，故都是一些生命周期较长的对象； 

持久代：用于存放静态文件，如Java类、方法等。 

新生代的垃圾收集器命名为“minor gc”，老生代的GC命名为”Full Gc 或者Major GC”.其中用System.gc()强制执行的是Full Gc. 

判断对象是否需要回收的方法有两种： 

1.引用计数 

当某对象的引用数为0时，便可以进行垃圾收集。 

2.对象引用遍历 

果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集。在对象遍历阶段，gc必须记住哪些对象可以到达，以便删除不可到达的对象，这称为标记（marking）对象。

触发GC（Garbage Collector）的条件： 

1)GC在优先级最低的线程中运行，一般在应用程序空闲即没有应用线程在运行时被调用。 

2)Java堆内存不足时，GC会被调用。

#### 63. jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代等

答：对象优先在新生代区中分配，若没有足够空间，Minor GC； 

大对象（需要大量连续内存空间）直接进入老年态；长期存活的对象进入老年态。如果对象在新生代出生并经过第一次MGC后仍然存活，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。

#### 64. 要回收哪些区域

在JVM内存模型中，有三个是不需要进行垃圾回收的：程序计数器、JVM栈、本地方法栈。因为它们的生命周期是和线程同步的，随着线程的销毁，它们占用的内存会自动释放，所以只有方法区和堆需要进行GC 

#### 65. 常用的垃圾回收算法

1、标记-清除算法 

标记-清除算法采用从根集合（GC Roots）进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，此算法一般没有虚拟机采用。 

优点1：解决了循环引用的问题 

优点2：与复制算法相比，不需要对象移动，效率较高，而且还不需要额外的空间 

不足1：每个活跃的对象都要进行扫描，而且要扫描两次，效率较低，收集暂停的时间比较长。 

不足2：产生不连续的内存碎片 

2、复制算法 

将内存分成两块容量大小相等的区域，每次只使用其中一块，当这一块内存用完了，就将所有存活对象复制到另一块内存空间，然后清除前一块内存空间。这样一来就不容易出现内存碎片的问题。 

1、复制的代价较高，所以适合新生代，因为新生代的对象存活率较低，需要复制的对象较少； 

2、需要双倍的内存空间，而且总是有一块内存空闲，浪费空间 

 

3、标记-整理算法 

思想：在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。 

不会产生内存碎片，但是依旧移动对象的成本。 

 

4、分代收集算法 

分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation）,在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。 

 

内存被分为下面三个区域：  

① 新生代：Enden、form survicor space、to survivor space。  

② 老年代  

③ 永久代：方法区 

#### 66. 新生代的回收算法

包含有Enden、form survicor space、to survivor space三个区，绝大多数最新被创建的对象会被分配到这里，大部分对象在创建之后会变得很快不可达。 

① 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。 

② 新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。 

③ 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。 

④ 新生代发生的GC也叫做Minor GC，Minor GC发生频率比较高(不一定等Eden区满了才触发)。 

老年代的回收算法  

①  在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 

② 内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。 

永久代的回收算法  

用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代也称方法区。 

#### 67. 常见的垃圾收集器

Serial收集器（复制算法) 

新生代单线程收集器，标记和清理都是单线程，优点是简单高效。是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定。 

Serial Old收集器(标记-整理算法) 

老年代单线程收集器，Serial收集器的老年代版本。 

ParNew收集器(停止-复制算法)　 

新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。 

Parallel Scavenge收集器(停止-复制算法)　 

并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数。 

Parallel Old收集器(停止-复制算法) 

Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先。 

CMS(Concurrent Mark Sweep)收集器（标记-清理算法） 

高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择。 

六、GC是什么时候触发的（面试最常见的问题之一） 

由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Minor GC和Full GC。 

Minor GC 

  一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Minor GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。 

Full GC 

对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC： 

a) 年老代（Tenured）被写满； 

b) 持久代（Perm）被写满； 

c) System.gc()被显示调用； 

d) 上一次GC之后Heap的各域分配策略动态变化； 

面试题：jvm查看gc命令 

jstat -gc 12538 5000 

即会每5秒一次显示进程号为12538的java进成的GC情况， 

面试题：如果频繁老年代回收怎么分析解决(蚂蚁金服面试题) 

（个人理解）老年代是存放那些在程序中经历了好几次回收仍然还活着或者特别大的对象（这个大就要看你是否设置了-XX：PretenureSizeThreshold 参数了）。检查程序中是否有比较大的对象，或者这个参数设置是否合理。

#### 68. 垃圾回收机制的主要解决问题

哪些内存需要回收,.什么时候回收,如何回收？

#### 69. 哪些内存需要回收

垃圾收集器会对堆进行回收前，确定对象中哪些是“存活”，哪些是”死亡“（不可能再被任何途径使用的对象）

判断方法：

1.引用计数算法

每当一个地方引用它时，计数器+1；引用失效时，计数器-1；计数值=0——不可能再被引用。

举例：

查看运行结果，会发现并没有因为两个对象互相引用就没有回收，因此引用计数算法很难解决对象之间相互矛盾循环引用的问题。

 

2.可达性分析算法：

向图，树图，把一系列“GC Roots”作为起始点，从节点向下搜索，路径称为引用链，当一个对象到GC Roots没有任何引用链相连，即不可达时，则证明此对象时不可用的。

 

举例：一颗树有很多丫枝，其中一个分支断了，跟树上没有任何联系，那就说明这个分支没有用了，就可以当垃圾回收去烧了。

注：在Java中可作为GCRoots的对象：

1).虚拟机栈（栈帧中的本地变量表）中引用的对象；

2).方法区中类静态属性引用的对象；

3).方法区中常量引用的对象；

4).本地方法栈中JNI引用的对象

#### 70. 垃圾回收器什么时候回收？

即使是被判断不可达的对象，也要再进行筛选，当对象没有覆盖finalize()方法，或者finalize方法已经被虚拟机调用过，则没有必要执行；

如果有必要执行——放置在F-Queue的队列中——Finalizer线程执行。

注意：对象可以在被GC时可以自我拯救(this)，机会只有一次，因为任何一个对象的finalize（）方法都只会被系统自动调用一次。并不建议使用，应该避免。使用try_finaly或者其他方式。

#### 71. 垃圾回收器如何回收

这就牵扯到垃圾收集算法和垃圾收集器，垃圾收集算法：

1.标记—清除算法

两个阶段：标记，清除；

不足：效率问题；空间问题(会产生大量不连续的内存碎片)

2.复制算法

将可用内存按容量分为大小相等的两块，每次都只使用其中一块；

不足：将内存缩小为了原来的一半

新生代

3.标记—整理算法

标记，清除（让存活的对象都向一端移动）

老年代